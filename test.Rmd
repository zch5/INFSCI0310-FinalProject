```{r}
library(tidyverse)
library(dplyr)
library(RCurl)
library(RJSONIO)
```


```{r}
setwd("C:\\Users\\zachh\\Pitt\\3 2021 Spring\\Computation in Information Science\\Final Project")
df1 <- read.csv("Air_Emission_Plant_-_General_Administrative_Location.csv")
print(data)

coordsx = select(df1, ï..X)
coordsy = select(df1, Y)
print(coordsx)
```



```{r}
# FCC's Census Block Conversions API
# http://www.fcc.gov/developers/census-block-conversions-api
latlong2fips <- function(latitude, longitude) {
  url <- "http://data.fcc.gov/api/block/find?format=json&latitude=%f&longitude=%f"
  url <- sprintf(url, latitude, longitude)
  json <- RCurl::getURL(url)
  json <- RJSONIO::fromJSON(json)
  as.character(json$County['FIPS'])
}

x = unlist(coordsx[1])
y = unlist(coordsy[1])

latlong2fips(latitude=x, longitude=y)

print(3)
```

```{r}
testpoints <- data.frame(x=c(coordsx[1], y=coordsy[1]))
test = latlong2fips(unlist(coordsx[1]), unlist(coordsy[1]))
print(test)
```
```{r}
library(sp)
library(maps)
library(maptools)

# The single argument to this function, pointsDF, is a data.frame in which:
#   - column 1 contains the longitude in degrees (negative in the US)
#   - column 2 contains the latitude in degrees

latlong2county <- function(pointsDF) {
    # Prepare SpatialPolygons object with one SpatialPolygon
    # per county
    counties <- map('county', fill=TRUE, col="transparent", plot=FALSE)
    IDs <- sapply(strsplit(counties$names, ":"), function(x) x[1])
    counties_sp <- map2SpatialPolygons(counties, IDs=IDs,
                     proj4string=CRS("+proj=longlat +datum=WGS84"))

    # Convert pointsDF to a SpatialPoints object 
    pointsSP <- SpatialPoints(pointsDF, 
                    proj4string=CRS("+proj=longlat +datum=WGS84"))

    # Use 'over' to get _indices_ of the Polygons object containing each point 
    indices <- over(pointsSP, counties_sp)

    # Return the county names of the Polygons object containing each point
    countyNames <- sapply(counties_sp@polygons, function(x) x@ID)
    countyNames[indices]
}

# Test the function using points in Wisconsin and Oregon.
testPoints <- data.frame(x = c(-94.64009, 27.12796), y = c(44, 44))

latlong2county(testPoints)
```
```{r}
library(rgdal)

utms <- SpatialPoints(data[, c(-8613944.2514, 5036536.7486)], proj4string=CRS(“+proj=utm +zone=10”)) #create UTM matrix

longlats <- spTransform(utms, CRS(“+proj=longlat”)) #transform
```
```{r}
wgs84 = "+init=epsg:4326"
bng = '+proj=tmerc +lat_0=49 +lon_0=-2 +k=0.9996012717 +x_0=400000 +y_0=-100000 
+ellps=airy +datum=OSGB36 +units=m +no_defs'

ConvertCoordinates <- function(easting,northing) {
out = cbind(easting,northing)
mask = !is.na(easting)
sp <-  sp::spTransform(sp::SpatialPoints(list(easting[mask],northing[mask]),proj4string=sp::CRS(bng)),sp::CRS(wgs84))
out[mask,]=sp@coords
out
}

coords = ConvertCoordinates(583964.35, 4507349.25)
print(coords)
```

